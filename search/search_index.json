{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"CMakeGuidelines","text":"<p>Collection of useful cmake tips.</p>"},{"location":"#12062023-superfluous-generator-expressions","title":"12/06/2023 Superfluous generator expressions","text":"<p>All that <code>$&lt;BUILD_INTERFACE:\u2026&gt;</code> and <code>$&lt;INSTALL_INTERFACE:\u2026&gt;</code> stuff is only needed for libraries you are installing. Do not copy-paste that stuff onto your executable targets. That includes tests. Even if you install an executable you don\u2019t need these generator expressions. Installed executables have no notion of include directories so you can use the much simpler form of target_include_directories which omits these.</p>"},{"location":"#05182023-fake-targets-and-namespacing","title":"05/18/2023 Fake targets and namespacing","text":"<p>This code will configure, compile, and link without errors: target_link_library(my-library PUBLIC this-target-absolute-does-not-exist) If you provide a link library without a namespace (in other words there is no :: in the name) CMake will first try to find a corresponding CMake target with that name. If it can\u2019t find a CMake target, it will instead just add -lthis-target-absolute-does-not-exist to the linker line because that may in fact really be a library you have somewhere on your machine. In practice this means that a subtle misspelling of your target name can easily result in linker errors. Conversely, if you use a namespaced target name and CMake cannot find that target, configuration fails. That means you find and fix these bugs much faster. As library authors this means adding a namespace to the targets in your export set and also providing an ALIAS target so that anyone consuming your library via add_subdirectory can use that namespaced target name as well. Discussed in this talk</p>"},{"location":"#11042022-no-build-type","title":"11/04/2022 No build type","text":"<p>The lack of a build type is not a debug build. The <code>CMAKE_BUILD_TYPE</code> variable can have values like <code>Debug</code> or <code>Release</code> but it can also be blank. When it\u2019s blank, CMake will not add flags like <code>-g</code>. It will simply omit those flags and you\u2019ll end up using more of your compiler\u2019s defaults. While the lack of a build type isn\u2019t necessary a problem and should never break your build, I still recommend always setting a build type so you know what you\u2019re getting.</p> <p>Notably, <code>CMAKE_BUILD_TYPE=None</code> is used by debian to inject build flags for packages.</p>"},{"location":"#11012022-clean-rebuilds","title":"11/01/2022 Clean rebuilds","text":"<p>CMake 3.24 adds a new <code>--fresh</code> flag which simplifies the process of doing clean rebuilds. This is the kind of feature you can use locally if you have 3.24 installed even if you\u2019re working on a project whose minimum version is lower. https://cmake.org/cmake/help/v3.24/manual/cmake.1.html#options </p>"},{"location":"#10272022-prefer-linking-over-package_include_dirs","title":"10/27/2022 Prefer linking over <code>Package_INCLUDE_DIRS</code>","text":"<p>Always prefer linking to a 3rd party target over using <code>${Package_INCLUDE_DIRS}</code>. 1. The target based approach is more generic and extensible. If a library author adds a new include directory or changes from a header-only to compiled library, you don\u2019t care. Everything just keeps working. 1. The variable-based solution is being phased out. Don\u2019t be surprised if a variable-based workflow which used to work silently breaks since that variable is now empty after a major update to a library. CMake will let you dereference empty variables so it\u2019s hard to know when this happens. 1. CMake will error out if a target is missing or has the wrong name. Unlike the above problem, targets give you much stronger guarantees when things go wrong. If a target does not exist or you just spelled it wrong, configuration halts and you\u2019re forced to fix it. 1. Using targets avoids the extra hassle of using the <code>$&lt;BUILD_INTERFACE&gt;</code> generator expression in your <code>target_include_directories</code> call. 1. It\u2019s simply less code to write. Target names tend to be shorter than variable names but beyond that, you often have to use the variable based approach in at least two places, once for include dirs and once for link libraries.  Linking to a target is only needed once and you\u2019re done.</p>"},{"location":"#10202022-project-description","title":"10/20/2022 Project Description","text":"<p>The <code>project()</code> call includes many optional arguments including <code>DESCRIPTION</code> which does what you\u2019d expect. It lets you specify a short string that describes the purpose of the project. This is useful for project like RSL which are an abbreviation for something longer so we put that whole name in the <code>DESCRIPTION</code> field. This also has the nice property of automatically appearing in your Doxygen docs since the <code>doxygen_add_docs</code> function checks the <code>PROJECT_DESCRIPTION</code> variable. </p>"},{"location":"#09302022-non-standalone-projects","title":"09/30/2022 Non-standalone projects","text":"<p>Only add <code>cmake_minimum_required</code> and <code>project</code> calls if you plan on building that directory as a standalone project. There are valid reasons to do this within a project but generally speaking if you write <code>add_subdirectory(some_dir)</code> then you don\u2019t need to include those two calls inside some_dir/CMakeLists.txt. At best this code is just a no-op. At worst it causes subtle bugs due to how <code>PROJECT_</code> prefixed variables and <code>CMAKE_</code> prefixed variables behave. (edited) </p>"},{"location":"#09062022-stop-quoting-paths","title":"09/06/2022 Stop quoting paths!","text":"<p>I was given old \u201cwisdom\u201d that if you dereference a variable that contains a path (for example, <code>CMAKE_SOURCE_DIR</code>) and that path contains a space, that one variable will actually expand into two arguments which are both broken paths. This is not true. Clone a project into a directory with a space in it and nothing will break. It\u2019s totally fine and not something you need to defend against. For example,</p> <pre><code>install(DIRECTORY include/\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n        COMPONENT mylib_headers)\n</code></pre> <p>There is no need to put quotes around <code>${CMAKE_INSTALL_INCLUDEDIR}</code>. I\u2019d go ever farther to actively recommend against adding those quotes because it reinforces that old school paranoia and makes it harder to know when quotes are truly necessary. When I see quotes in CMake I expect that\u2019s because the quotes are provably required because in some instances they are actually very important.</p>"},{"location":"#08292022-use-trailing-forward-slashes-with-intent","title":"08/29/2022 Use trailing forward slashes with intent","text":"<p>Trailing slashes on paths are sometimes very meaningful. Take the two snippets</p> <pre><code>install(DIRECTORY include\n        DESTINATION .\n        COMPONENT libname_headers)\n</code></pre> <pre><code>install(DIRECTORY include/\n        DESTINATION ${CMAKE_INSTALL_INCLUDEDIR}\n        COMPONENT libname_headers)\n</code></pre> <p>The first snippet installs the <code>include</code> directory including a directory named <code>include</code>. The second snippets installs the contents of the <code>include</code> directory but not the <code>include</code> directory itself. Both examples will do what you want the latter is preferable since it gives you more control over the directory into which your headers get installed. For all I know you want to install your headers into a directory named <code>headers</code> instead of <code>include</code> and the 2nd form gives you (and those installing your library) that control. Pay attention to those trailing backslahes next time you\u2019re debugging install code!</p>"},{"location":"#08262022-enable-lto-link-time-optimization","title":"08/26/2022 Enable LTO (link-time optimization)","text":"<p>Use <code>CMAKE_INTERPROCEDURAL_OPTIMIZATION</code> to easily enable link-time optimization (LTO) for a project. On the command line this looks like <code>-DCMAKE_INTERPROCEDURAL_OPTIMIZATION=ON</code>. Hardcoding this for your project looks like <code>set(CMAKE_INTERPROCEDURAL_OPTIMIZATION ON)</code>. CMake knows whether or not your compiler supports LTO so nothing should fail if your compiler does not support it. https://cmake.org/cmake/help/latest/variable/CMAKE_INTERPROCEDURAL_OPTIMIZATION.html</p>"},{"location":"#08242022-listappend","title":"08/24/2022 <code>list(APPEND</code>","text":"<p>Use <code>list(APPEND</code> to add elements to a list like so</p> <pre><code>set(MY_VARIABLE element1)\n...\nlist(APPEND MY_VARIABLE element2 element3)\n</code></pre> <p>over the more verbose alternative</p> <pre><code>set(MY_VARIABLE element1)\n...\nset(MY_VARIABLE ${MY_VARIABLE} element2 element3)\n</code></pre> <p>Don\u2019t repeat yourself if you don\u2019t need to! I\u2019ll also briefly mention <code>list(PREPEND</code> if you need to prepend instead of append to a list. <code>list</code> has tons of options for manipulating lists that are all better than trying to re-implement it by hand with lots of set calls.</p>"},{"location":"#08152022-generateexportheader","title":"08/15/2022 <code>GenerateExportHeader</code>","text":"<p>Use the GenerateExportHeader module to generate a header that defines macros for symbol export. GCC and Clang export all symbols by default but if you want better control over what symbols are public in your .so, you need to use non-portable compile attributes to specify that. This CMake module automates a lot of the busy work required to generate those macros and does so in a way that works on all platforms, including Windows. I\u2019ve used this before and it\u2019s not too hard to get set up with. I\u2019d definitely recommend this if you\u2019re hardcore about not letter users depend on implementation details.</p>"},{"location":"#08112022-cmake_-vs-project_","title":"08/11/2022 <code>CMAKE_</code> vs <code>PROJECT_</code>","text":"<p>When two variables have the same name but one has a <code>CMAKE_</code> prefix and the other a <code>PROJECT_</code> prefix, the difference is that the <code>CMAKE_</code> prefixed version refers to the top level project. The <code>PROJECT_</code> prefixed version refers to the whatever project is currently being configured. They often mean the same thing but they\u2019re different when you have projects inside projects like through the use of git submodules or using <code>FetchContent</code> to bring it outside projects. For example, <code>PROJECT_SOURCE_DIR</code> is the root of the project currently being configured. If you\u2019re writing a library, this is usually what you should be using since you can be certain that it will always refer to the root of your library even if someone takes your project and puts it inside their project. <code>CMAKE_SOURCE_DIR</code> refers to the top level CMakeListst.xt file that was passed to <code>cmake</code>. When you run <code>cmake -S. -B build</code> you\u2019re saying the current directory is the <code>CMAKE_SOURCE_DIR</code>. Within that CMakeLists.txt you can add as many outside projects as you like and each outside project will have a different <code>PROJECT_SOURCE_DIR</code> but <code>CMAKE_SOURCE_DIR</code> will only ever refer to the same directory no matter where it\u2019s used.</p>"},{"location":"#08102022-endif-conditional","title":"08/10/2022 <code>endif</code> conditional","text":"<p>Do this</p> <pre><code>if(SOME_CONDITION)\n   ...\nendif()\n</code></pre> <p>not this</p> <pre><code>if(SOME_CONDITION)\n   ...\nendif(SOME_CONDITION)\n</code></pre> <p>Surprisingly the 2nd form is valid and behaves the same as the first. There\u2019s no good reason to be repeating yourself in the endif call. It\u2019s entirely unnecessary and just makes the code harder to read and maintain.</p>"},{"location":"references/","title":"References","text":"<ul> <li>Argon has a good collection of cmake files</li> </ul>"}]}